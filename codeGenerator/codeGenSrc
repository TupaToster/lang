DEFCMD (SC, ";", 2, {

    if (Token->type == SC) {

        Token++;
        return;
    }
    else call_next (tree, iter, token, varTable, funcTable);
})

DEFCMD (EQ, "=", 1)

DEFCMD (LESS, "<", 1)

DEFCMD (GREATER, ">", 1)

DEFCMD (EQEQ, "==", 1)

DEFCMD (LESSEQ, "<=", 1)

DEFCMD (GREATEREQ, ">=", 1)

DEFCMD (PLUS, "+", 1)

DEFCMD (MINUS, "-", 1)

DEFCMD (MULT, "*", 1)

DEFCMD (DIV, "/", 1)

DEFCMD (RB, ")", 2, {

    if (Token->type == LB) {

        set (tree, {
            Token++;
            Get_1 (tree, iter, token, varTable, funcTable);
            assert (Token->type == RB);
            Token++;
        })
    }
    else call_next (tree, iter, token, varTable, funcTable);
})

DEFCMD (INT_CONST, "_INT_CONST", 3)

DEFCMD (DOUBLE_CONST, "_DOUBLE_CONST", 3)

DEFCMD (CHAR_CONST, "_CHAR_CONST", 3)

DEFCMD (STR_CONST, "_STR_CONST", 3)

DEFCMD (FUNC, "_FUNC", 2, {

        if (IS_TYPE (Token->type)) {

            assert (inSize - 1);
            assert ((Token + 1)->type == BLANK);

            if (inSize - 2 and !(inSize - 3) or (Token + 2)->type != LB) {

                call_next (tree, iter, token, varTable, funcTable);
                return;
            }

            Nod* funcPtr = Token + 1;

            set (tree, {

                (Token + 1)->type = FUNC;
                (Token + 1)->push_back (Token);
                Token->prev = Token + 1;
                iter->push_back (Token + 1);
                (Token + 1)->prev = iter;
            })

            Token += 2;

            assert (Token->type == LB);

            Token++;

            assert (inSize);
            while (Token->type != RB) {

                call_next (tree, funcPtr, token, varTable, funcTable);
                assert (inSize);
                if (Token->type == RB) break;
                assert (Token->type == COMA);
                Token++;
            }

            Token++;
            assert (inSize);
            assert (Token->type == LFB);

            Token++;
            while (Token->type != RFB) Get_1 (tree, funcPtr, token, varTable, funcTable);

            assert (inSize);
            assert (Token->type == RFB);
            Token++;
        }
        else call_next (tree, iter, token, varTable, funcTable);
})

DEFCMD (VAR, "_VAR", 2, {

    if (IS_TYPE (Token->type)){

        Token++;
        assert (inSize);
        assert (Token->type == BLANK);

        set (tree, {

            Token->type = VAR;
            Token->push_back (Token - 1);
            (Token -1)->prev = Token;
            Token->prev = iter;
            iter->push_back (Token);
        })

        Token++;

        if (inSize and Token->type == EQ) {

            Token++;
            assert (inSize);
            if (INT_MATCH ((Token - 3)->type, Token->type) or
                DOUBLE_MATCH ((Token - 3)->type, Token->type) or
                CHAR_MATCH ((Token - 3)->type, Token->type)) {

                    set (tree, {

                        (Token - 3)->val = Token->val;
                    })
                }
            else if (STR_MATCH ((Token - 3)->type, Token->type)){

                set (tree, {

                    (Token - 3)->val.STR = strdup (Token->val.STR);
                    printf ("%p : %p", (Token - 3)->val.STR, Token->val.STR);
                    assert ((Token - 3)->val.STR != NULL);
                })
            }
            else assert ("Error of kind: <type> <var_name> = <wrong_type>; or <type> <var_name> = ;\n\n" == NULL);

            Token++;
        }
    }
})

DEFCMD (INT, "int", 0)

DEFCMD (DOUBLE, "double", 0)

DEFCMD (CHAR, "char", 0)

DEFCMD (STR, "string", 0)

DEFCMD (LB, "(", 0)

DEFCMD (LFB, "{", 0)

DEFCMD (RFB, "}", 0)

DEFCMD (COMA, ",", 0)